// SPDX-License-Identifier: GPL-2.0-or-later
{
  parserClass="org.openstreetmap.josm.idea.mapcss_intellij.parser.MapCSSParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="MapCSS"
  psiImplClassSuffix="Impl"
  psiPackage="org.openstreetmap.josm.idea.mapcss_intellij.psi"
  psiImplPackage="org.openstreetmap.josm.idea.mapcss_intellij.psi.impl"

  elementTypeHolderClass="org.openstreetmap.josm.idea.mapcss_intellij.psi.MapCSSTypes"
  elementTypeClass="org.openstreetmap.josm.idea.mapcss_intellij.psi.MapCSSElementType"
  tokenTypeClass="org.openstreetmap.josm.idea.mapcss_intellij.psi.MapCSSTokenType"
  tokens=[
    PP_AND="and"
    PP_OR="or"
    PP_NOT="not"
    PP_SUPPORTS="@supports"
    PP_WHITESPACE="regexp:[ \t]"
    SET="set"
    UINT="regexp:\d+"
    STRING="regexp:(['\"]).*?[^\\]\1"
    PREDEFINED="\\[dDsSwWbBAGZz]"
    //REGEX_CHAR_WITHOUT_STAR="regexp:[ -)+-.,0-[]-~\u0080-\uFFFF]|\\/|\\\\|\\[|\\]|\\+|\\.|\\'|\\\"|\\(|\\)|\\{|\\}|\\?|\\*|\\^|\\$|\\|\\p|PREDEFINED" // FIXME
    //REGEX="regexp:/" REGEX_CHAR_WITHOUT_STAR "(" REGEX_CHAR_WITHOUT_START "|*)*/" // FIXME
    LBRACE="{"
    RBRACE="}"
    LPAR="("
    RPAR=")"
    COMMA=","
    COLON=":"
    UFLOAT="regexp:(\d)+(.\d+)?"
    HEXCOLOR="regexp:#([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})"
    space="regexp:[ \t\n\r\f]+"
    block_comment="regexp:/\*(.|\n)*?\*/" // This is a "special" token
    STAR="*"
    SLASH="/"
    LSQUARE="["
    RSQUARE="]"
    GREATER_EQUAL=">="
    LESS_EQUAL="<="
    GREATER=">"
    LESS="<"
    EXCLAMATION="!"
    TILDE="~"
    DCOLON="::"
    SEMICOLON=";"
    PIPE="|"
    PIPE_Z="|z"
    PLUS="+"
    MINUS="-"
    AMPERSAND="&"
    QUESTION="?"
    DOLLAR="$"
    FULLSTOP="."
    DEG="°"
    SUBSET_OR_EQUAL="regexp:[∈⊆]"
    NOT_SUBSET_OR_EQUAL="⊈"
    SUPERSET_OR_EQUAL="⊇"
    NOT_SUPERSET_OR_EQUAL="⊉"
    CROSSING="⧉"
    PERCENT="%"
    NODE="node"
    WAY="way"
    RELATION="relation"
    META="meta"
    AREA="area"
    CANVAS="canvas"
    LINE="line"
    AT="@"
    IDENT="regexp:[a-zA-Z_]([a-zA-Z_0-9-])*"
  ]
}

root ::= root_item * {pin=1 recoverWhile=eof_recover}

private root_item ::= !<<eof>> (rule | import2) {pin=1 recoverWhile=rule_recover}

rule         ::= <<comma_separated_list selector>>;

import2       ::= AT "import" "url" LPAR STRING RPAR IDENT SEMICOLON {pin=1 recoverWhile=statement_recover};

zoom         ::= PIPE "z" range;

selector  ::= (object | object zoom | object zoom tests | object tests | object maybeClazz) declarations {pin=1 recoverWhile=rule_recover};

range        ::= UINT | UINT MINUS UINT | UINT MINUS | MINUS UINT;

tests        ::= test+;// | tests test;

test         ::= LSQUARE condition RSQUARE;

condition    ::= key binary specifier | unary key | key;

key          ::= IDENT;

binary       ::= "=" | "!=" | "=~" | GREATER | LESS | GREATER_EQUAL | LESS_EQUAL;

unary        ::= MINUS | EXCLAMATION;

maybeClazz   ::= clazz | EXCLAMATION clazz;

clazz        ::= FULLSTOP IDENT | COLON IDENT;

object       ::= (NODE | WAY | RELATION | AREA | LINE | CANVAS | STAR | META)
meta comma_separated_list ::= <<param>> ( COMMA <<param>> ) *
meta semi_colon_separated_list ::= <<param>> ( SEMICOLON <<param>> )* SEMICOLON
declarations ::= declaration+;

declaration  ::= LBRACE styleset RBRACE {pin=1 recoverWhile=rule_recover};

inner styleset     ::= <<semi_colon_separated_list style>>
inner style        ::= key COLON specifier {pin=2 recoverWhile=statement_recover};

specifier    ::= IDENT | sizes | colour | url | eval | STRING | UINT | UFLOAT;

sizes        ::= <<comma_separated_list size>>;

size         ::= UFLOAT units;

colour       ::= HEXCOLOR | "rgb" LPAR UFLOAT COMMA UFLOAT COMMA UFLOAT RPAR | "rgba" LPAR UFLOAT COMMA UFLOAT COMMA UFLOAT COMMA UFLOAT RPAR;

url          ::= "url" LPAR urlContent RPAR;

urlContent   ::= QUOTED | eval;

units        ::= "px" | "pt" | PERCENT | ;

eval         ::= "eval" LPAR QUOTED RPAR;

private eof_recover ::= !(<<eof>>)
private rule_recover ::= !(RBRACE)
private statement_recover ::= !(SEMICOLON)